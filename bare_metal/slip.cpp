/*
 * slip.cpp
 *
 *  Created on: 25 Sep 2014
 *      Author: simon
 */

#include "slip.h"
#include "common.h"
#include "IoSpace.h"
#include <string.h>

namespace Slip
{

//http://tools.ietf.org/html/rfc1055

   /* SLIP special character codes
    */
   #define END             0300    /* indicates end of packet */
   #define ESC             0333    /* indicates byte stuffing */
   #define ESC_END         0334    /* ESC ESC_END means END data byte */
   #define ESC_ESC         0335    /* ESC ESC_ESC means ESC data byte */

   /* SEND_PACKET: sends a packet of length "len", starting at
    * location "p".
    */
   void send_packet(unsigned char *p, int len, GenericByteTxRx &rTxRx) {

     /* send an initial END character to flush out any data that may
      * have accumulated in the receiver due to line noise
      */
//        send_char(END);
	   while (!rTxRx.WriteByte(END));

     /* for each byte in the packet, send the appropriate character
      * sequence
      */
           while(len--) {
                   switch(*p) {
                   /* if it's the same code as an END character, we send a
                    * special two character code so as not to make the
                    * receiver think we sent an END
                    */
                   case END:
//                           send_char(ESC);
//                           send_char(ESC_END);
						   while (!rTxRx.WriteByte(ESC));
						   while (!rTxRx.WriteByte(ESC_END));
                           break;

                   /* if it's the same code as an ESC character,
                    * we send a special two character code so as not
                    * to make the receiver think we sent an ESC
                    */
                   case ESC:
//                           send_char(ESC);
//                           send_char(ESC_ESC);
                	   	   while (!rTxRx.WriteByte(ESC));
                	   	   while (!rTxRx.WriteByte(ESC_ESC));
                           break;
                   /* otherwise, we just send the character
                    */
                   default:
//                           send_char(*p);
                	   	   while (!rTxRx.WriteByte(*p));
                           }

                   p++;
                   }

           /* tell the receiver that we're done sending the packet
            */
//           send_char(END);
           while (!rTxRx.WriteByte(END));
           }

   /* RECV_PACKET: receives a packet into the buffer located at "p".
    *      If more than len bytes are received, the packet will
    *      be truncated.
    *      Returns the number of bytes stored in the buffer.
    */
   int recv_packet(unsigned char *p, int len, GenericByteTxRx &rTxRx) {
           unsigned char c;
           int received = 0;

           /* sit in a loop reading bytes until we put together
            * a whole packet.
            * Make sure not to copy them into the packet if we
            * run out of room.
            */
           while(1) {
                   /* get a character to process
                    */
//                   c = recv_char();
        	   	   while (!rTxRx.ReadByte(c));

                   /* handle bytestuffing if necessary
                    */
                   switch(c) {

                   /* if it's an END character then we're done with
                    * the packet
                    */
                   case END:
                           /* a minor optimization: if there is no
                            * data in the packet, ignore it. This is
                            * meant to avoid bothering IP with all
                            * the empty packets generated by the
                            * duplicate END characters which are in
                            * turn sent to try to detect line noise.
                            */
                           if(received)
                                   return received;
                           else
                                   break;

                   /* if it's the same code as an ESC character, wait
                    * and get another character and then figure out
                    * what to store in the packet based on that.
                    */
                   case ESC:
                           while (!rTxRx.ReadByte(c));

                           /* if "c" is not one of these two, then we
                            * have a protocol violation.  The best bet
                            * seems to be to leave the byte alone and
                            * just stuff it into the packet
                            */
                           switch(c) {
                           case ESC_END:
                                   c = END;
                                   break;
                           case ESC_ESC:
                                   c = ESC;
                                   break;
                           default:
                        	   break;
                                   }

                   /* here we fall into the default handler and let
                    * it store the character for us
                    */
                   default:
                           if(received < len)
                                   p[received++] = c;
                           }
                   }
           }



void HalfDuplex(GenericByteTxRx &rTxRx, Rpc<unsigned char, unsigned int> &rRpc)
{
	static const int kMtu = 1500;

	while (!rRpc.ShouldQuit())
	{
		if (rTxRx.RxData())
		{
			unsigned int length;
			unsigned char *pPacket = rRpc.Alloc(kMtu);
			ASSERT(pPacket);

			length = recv_packet(pPacket, kMtu, rTxRx);

			rRpc.NotifyNew(pPacket, length);
		}

		unsigned char *pPacket; unsigned int length;
		if (rRpc.Transmit(&pPacket, &length))
		{
			Slip::send_packet(pPacket, length, rTxRx);

			rRpc.SendAck(pPacket);
		}

		if (rRpc.RecvAck(&pPacket))
			rRpc.Free(pPacket);
	}
}

static inline void Tx(GenericByteTxRx &rTxRx, Rpc<unsigned char, unsigned int> &rRpc,
							unsigned char *&pSendPacket,
							unsigned int &sent,
							unsigned int &to_send,
							bool &initial_end_sent,
							bool &must_send_esc_esc,
							bool &must_send_esc_end,
							bool &final_end_sent)
{
	//get more work?
	if (!to_send && !pSendPacket)
	{
		if (rRpc.Transmit(&pSendPacket, &to_send))
		{
			ASSERT(pSendPacket);
			ASSERT(to_send);

			initial_end_sent = false;
			must_send_esc_end = false;
			must_send_esc_esc = false;
			final_end_sent = false;

			sent = 0;
		}
	}

	//tell it it's done?
	if (!to_send && pSendPacket)
	{
		if (final_end_sent)
		{
			rRpc.SendAck(pSendPacket);
			pSendPacket = 0;
		}
		else if (!rTxRx.TxFull())
		{
			final_end_sent = true;
			rTxRx.WriteByte(END);
		}
	}

	//free some memory?
	{
		unsigned char *pToFree;
		if (rRpc.RecvAck(&pToFree))
			rRpc.Free(pToFree);
	}

	//data to send, and can send
	if (to_send && !rTxRx.TxFull())
	{
		//the initial end at the beginning of the packet
		if (!initial_end_sent)
		{
			rTxRx.WriteByte(END);
			initial_end_sent = true;
		}
		else if (must_send_esc_end)			//finishing of the 'end' escape seq
		{
			rTxRx.WriteByte(ESC_END);
			must_send_esc_end = false;
			sent++;
			to_send--;
		}
		else if (must_send_esc_esc)			//finishing of the 'esc' escape seq
		{
			rTxRx.WriteByte(ESC_ESC);
			must_send_esc_esc = false;
			sent++;
			to_send--;
		}
		else		//read/write data like normal
		{
			unsigned char c = pSendPacket[sent];
			switch (c)
			{
				case END:
					rTxRx.WriteByte(ESC);
					must_send_esc_end = true;
					break;

				case ESC:
					rTxRx.WriteByte(ESC);
					must_send_esc_esc = true;
					break;

				default:
					rTxRx.WriteByte(c);
					sent++;
					to_send--;
			}
		}
	}
}


void FullDuplex(GenericByteTxRx &rTxRx, Rpc<unsigned char, unsigned int> &rRpc)
{
	static const int kMtu = 1500;

	unsigned char *pRecvPacket = 0;
	unsigned int received = 0;

	unsigned char *pSendPacket = 0;
	unsigned int sent = 0;
	unsigned int to_send = 0;

	bool initial_end_sent = false;
	bool must_send_esc_esc = false;
	bool must_send_esc_end = false;
	bool final_end_sent = false;

	while (!rRpc.ShouldQuit())
	{
		//check for a new character
		if (rTxRx.RxData())
		{
			unsigned char c;
			if (!rTxRx.ReadByte(c))
				ASSERT(0);

			//get some storage for this packet
			if (!pRecvPacket)
			{
				pRecvPacket = (unsigned char *)rRpc.Alloc(kMtu);
				ASSERT(pRecvPacket);
			}

			switch (c)
			{
				case END:
				{
					//if we've received actual data
					if (received)
					{
						rRpc.NotifyNew(pRecvPacket, received);
						pRecvPacket = 0;
						received = 0;
					}
					//if not, drop the packet but keep the storage
					break;
				}

				case ESC:
				{
					//wait for the character which has been escaped
					while (!rTxRx.ReadByte(c))
					{
						Tx(rTxRx, rRpc,
							pSendPacket, sent, to_send,
							initial_end_sent, must_send_esc_esc, must_send_esc_end, final_end_sent);

						if (rRpc.ShouldQuit())
							return;
					}

					switch (c)
					{
						//get the original character
						case ESC_END:
							c = END;
							break;
						case ESC_ESC:
							c = ESC;
							break;
						default:
							//there should be nothing here, but if
							//something is received it is junk
							break;
					}
				}
				/* no break */

				default:
					if (received < kMtu)
						pRecvPacket[received++] = c;
			}
		}

		Tx(rTxRx, rRpc,
				pSendPacket, sent, to_send,
				initial_end_sent, must_send_esc_esc, must_send_esc_end, final_end_sent);
	}
}

SlipLink::SlipLink()
: LinkIntf(),
  m_thisAddr(1),
  m_otherAddr(2)
{
}

SlipLink::~SlipLink()
{
}

MailboxSlipLink::MailboxSlipLink(InterruptController *pPic)
: SlipLink(),
  m_mailbox(IoSpace::GetDefaultIoSpace()->Get("Mailbox"), pPic ? true : false),
  m_rAddrSend(m_mailbox.GetQueue(0)),
  m_rLenSend(m_mailbox.GetQueue(1)),
  m_rAddrRecv(m_mailbox.GetQueue(2)),
  m_rLenRecv(m_mailbox.GetQueue(3)),
  m_rSendAck(m_mailbox.GetQueue(5)),
  m_rRecvAck(m_mailbox.GetQueue(4))
{
//	m_packetAllocator.Init((Packet *)mspace_malloc(GetUncachedPool(), 15000));

	if (pPic)
	{
		pPic->RegisterInterrupt(m_rLenSend);
		pPic->RegisterInterrupt(m_rSendAck);

		m_rLenSend.SetInterruptType(OMAP4460::Mailbox::kNewMessage);
#ifdef __ARM_ARCH_7A__
		m_rLenSend.OnInterrupt([](InterruptSource &rSource)
				{
					OMAP4460::Mailbox::Queue *pQueue = (OMAP4460::Mailbox::Queue *)&rSource;

					if (pQueue->HandleInterruptDisable())
						pQueue->GetSemaphore().SignalAtomic();
				}
		);
#endif

		m_rLenSend.EnableInterrupt(true);

		m_rSendAck.SetInterruptType(OMAP4460::Mailbox::kNewMessage);
#ifdef __ARM_ARCH_7A__
		m_rSendAck.OnInterrupt([](InterruptSource &rSource)
				{
					OMAP4460::Mailbox::Queue *pQueue = (OMAP4460::Mailbox::Queue *)&rSource;

					if (pQueue->HandleInterruptDisable())
						pQueue->GetSemaphore().SignalAtomic();
				}
		);
#endif

		m_rSendAck.EnableInterrupt(true);
	}
}

MailboxSlipLink::~MailboxSlipLink()
{
}

bool MailboxSlipLink::SendTo(LinkAddrIntf& rDest, void* pData, unsigned int len)
{
	if (&rDest != &m_otherAddr)
		return false;

	if (len > GetMtu())
		return false;

	m_rAddrRecv.WriteMessage((unsigned int)pData - 0xa0600000);
	m_rLenRecv.WriteMessage(len);

#ifdef __ARM_ARCH_7A__
	m_rSendAck.GetSemaphore().Wait();
	ASSERT(m_rSendAck.NumUnreadMessages());
#else
	while (!m_rSendAck.NumUnreadMessages());
#endif

	unsigned int m = m_rSendAck.ReadMessage();
	ASSERT(m == (unsigned int)pData - 0xa0600000);

	return true;
}

bool MailboxSlipLink::Recv(LinkAddrIntf **ppFrom, void* pData, unsigned int& rLen, unsigned int maxLen)
{
#ifdef __ARM_ARCH_7A__
	m_rLenSend.GetSemaphore().Wait();
#endif

	if (m_rLenSend.NumUnreadMessages())
	{
		unsigned int pAddr = m_rAddrSend.ReadMessage() + 0xa0600000;
		unsigned int length = m_rLenSend.ReadMessage();

		unsigned int to_copy = length > maxLen ? maxLen : length;
		memcpy(pData, (void *)pAddr, to_copy);

		m_rRecvAck.WriteMessage(pAddr - 0xa0600000);

		*ppFrom = &m_otherAddr;
		rLen = to_copy;
		return true;
	}
	else
		return false;
}


SynchronousSlipLink::SynchronousSlipLink(GenericByteTxRx& rTxRx)
: SlipLink(),
  m_rTxRx(rTxRx)
{
}


SynchronousSlipLink::~SynchronousSlipLink()
{
}


bool SynchronousSlipLink::SendTo(LinkAddrIntf& rDest, void* pData,
		unsigned int len)
{
	if (&rDest != &m_otherAddr)
		return false;

	if (len > GetMtu())
		return false;

	send_packet((unsigned char *)pData, len, m_rTxRx);
	return true;
}


bool SynchronousSlipLink::Recv(LinkAddrIntf** ppFrom, void* pData,
		unsigned int& rLen, unsigned int maxLen)
{
#ifdef __ARM_ARCH_7A__
	m_rTxRx.GetRxWait().Wait();
	//can't guarantee there will be data
	//as we read extra data below
	//we may pass through the semaphore after we've already consumed the data
//	ASSERT(m_rTxRx.RxData());
#endif

	if (m_rTxRx.RxData())
	{
		rLen = recv_packet((unsigned char *)pData, maxLen, m_rTxRx);
		return true;
	}

	return false;
}


}
